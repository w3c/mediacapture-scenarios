<!DOCTYPE html>
<html lang="en-US-x-Hixie"><head><title>Recording Proposal &#8212; HTML5</title><link rel="stylesheet" href="alert.css"><style type="text/css">
   pre { margin-left: 2em; white-space: pre-wrap; }
   h2 { margin: 3em 0 1em 0; }
   h3 { margin: 2.5em 0 1em 0; }
   h4 { margin: 2.5em 0 0.75em 0; }
   h5, h6 { margin: 2.5em 0 1em; }
   h1 + h2, h1 + h2 + h2 { margin: 0.75em 0 0.75em; }
   h2 + h3, h3 + h4, h4 + h5, h5 + h6 { margin-top: 0.5em; }
   p { margin: 1em 0; }
   hr:not(.top) { display: block; background: none; border: none; padding: 0; margin: 2em 0; height: auto; }
   dl, dd { margin-top: 0; margin-bottom: 0; }
   dt { margin-top: 0.75em; margin-bottom: 0.25em; clear: left; }
   dt + dt { margin-top: 0; }
   dd dt { margin-top: 0.25em; margin-bottom: 0; }
   dd p { margin-top: 0; }
   dd dl + p { margin-top: 1em; }
   dd table + p { margin-top: 1em; }
   p + * > li, dd li { margin: 1em 0; }
   dt, dfn { font-weight: bold; font-style: normal; }
   i, em { font-style: italic; }
   dt dfn { font-style: italic; }
   pre, code { font-size: inherit; font-family: monospace; font-variant: normal; }
   pre strong { color: black; font: inherit; font-weight: bold; background: yellow; }
   pre em { font-weight: bolder; font-style: normal; }
   @media screen { code { color: orangered; } code :link, code :visited { color: inherit; } }
   var sub { vertical-align: bottom; font-size: smaller; position: relative; top: 0.1em; }
   table { border-collapse: collapse; border-style: hidden hidden none hidden; }
   table thead, table tbody { border-bottom: solid; }
   table tbody th:first-child { border-left: solid; }
   table tbody th { text-align: left; }
   table td, table th { border-left: solid; border-right: solid; border-bottom: solid thin; vertical-align: top; padding: 0.2em; }
   blockquote { margin: 0 0 0 2em; border: 0; padding: 0; font-style: italic; }

   .bad, .bad *:not(.XXX) { color: gray; border-color: gray; background: transparent; }
   .matrix, .matrix td { border: none; text-align: right; }
   .matrix { margin-left: 2em; }
   .dice-example { border-collapse: collapse; border-style: hidden solid solid hidden; border-width: thin; margin-left: 3em; }
   .dice-example caption { width: 30em; font-size: smaller; font-style: italic; padding: 0.75em 0; text-align: left; }
   .dice-example td, .dice-example th { border: solid thin; width: 1.35em; height: 1.05em; text-align: center; padding: 0; }

   .toc dfn, h1 dfn, h2 dfn, h3 dfn, h4 dfn, h5 dfn, h6 dfn { font: inherit; }
   img.extra, p.overview { float: right; }
   pre.idl { border: solid thin; background: #EEEEEE; color: black; padding: 0.5em 1em; position: relative; }
   pre.idl :link, pre.idl :visited { color: inherit; background: transparent; }
   pre.idl::before { content: "IDL"; font: bold small sans-serif; padding: 0.5em; background: white; position: absolute; top: 0; margin: -1px 0 0 -4em; width: 1.5em; border: thin solid; border-radius: 0 0 0 0.5em }
   pre.css { border: solid thin; background: #FFFFEE; color: black; padding: 0.5em 1em; }
   pre.css:first-line { color: #AAAA50; }
   dl.domintro { color: green; margin: 2em 0 2em 2em; padding: 0.5em 1em; border: none; background: #DDFFDD; }
   hr + dl.domintro, div.impl + dl.domintro { margin-top: 2.5em; margin-bottom: 1.5em; }
   dl.domintro dt, dl.domintro dt * { color: black; text-decoration: none; }
   dl.domintro dd { margin: 0.5em 0 1em 2em; padding: 0; }
   dl.domintro dd p { margin: 0.5em 0; }
   dl.domintro:before { display: table; margin: -1em -0.5em -0.5em auto; width: auto; content: 'This box is non-normative. Implementation requirements are given below this box.'; color: black; font-style: italic; border: solid 2px; background: white; padding: 0 0.25em; }
   dl.switch { padding-left: 2em; }
   dl.switch > dt { text-indent: -1.5em; }
   dl.switch > dt:before { content: '\21AA'; padding: 0 0.5em 0 0; display: inline-block; width: 1em; text-align: right; line-height: 0.5em; }
   dl.triple { padding: 0 0 0 1em; }
   dl.triple dt, dl.triple dd { margin: 0; display: inline }
   dl.triple dt:after { content: ':'; }
   dl.triple dd:after { content: '\A'; white-space: pre; }
   .diff-old { text-decoration: line-through; color: silver; background: transparent; }
   .diff-chg, .diff-new { text-decoration: underline; color: green; background: transparent; }
   a .diff-new { border-bottom: 1px blue solid; }

   h2 { page-break-before: always; }
   h1, h2, h3, h4, h5, h6 { page-break-after: avoid; }
   h1 + h2, hr + h2.no-toc { page-break-before: auto; }

   p  > span:not([title=""]):not([class="XXX"]):not([class="impl"]):not([class="note"]),
   li > span:not([title=""]):not([class="XXX"]):not([class="impl"]):not([class="note"]), { border-bottom: solid #9999CC; }

   div.head { margin: 0 0 1em; padding: 1em 0 0 0; }
   div.head p { margin: 0; }
   div.head h1 { margin: 0; }
   div.head .logo { float: right; margin: 0 1em; }
   div.head .logo img { border: none } /* remove border from top image */
   div.head dl { margin: 1em 0; }
   div.head p.copyright, div.head p.alt { font-size: x-small; font-style: oblique; margin: 0; }

   body > .toc > li { margin-top: 1em; margin-bottom: 1em; }
   body > .toc.brief > li { margin-top: 0.35em; margin-bottom: 0.35em; }
   body > .toc > li > * { margin-bottom: 0.5em; }
   body > .toc > li > * > li > * { margin-bottom: 0.25em; }
   .toc, .toc li { list-style: none; }

   .brief { margin-top: 1em; margin-bottom: 1em; line-height: 1.1; }
   .brief li { margin: 0; padding: 0; }
   .brief li p { margin: 0; padding: 0; }

   .category-list { margin-top: -0.75em; margin-bottom: 1em; line-height: 1.5; }
   .category-list::before { content: '\21D2\A0'; font-size: 1.2em; font-weight: 900; }
   .category-list li { display: inline; }
   .category-list li:not(:last-child)::after { content: ', '; }
   .category-list li > span, .category-list li > a { text-transform: lowercase; }
   .category-list li * { text-transform: none; } /* don't affect <code> nested in <a> */

   .XXX { color: #E50000; background: white; border: solid red; padding: 0.5em; margin: 1em 0; }
   .XXX > :first-child { margin-top: 0; }
   p .XXX { line-height: 3em; }
   .annotation { border: solid thin black; background: #0C479D; color: white; position: relative; margin: 8px 0 20px 0; }
   .annotation:before { position: absolute; left: 0; top: 0; width: 100%; height: 100%; margin: 6px -6px -6px 6px; background: #333333; z-index: -1; content: ''; }
   .annotation :link, .annotation :visited { color: inherit; }
   .annotation :link:hover, .annotation :visited:hover { background: transparent; }
   .annotation span { border: none ! important; }
   .note { color: green; background: transparent; font-family: sans-serif; }
   .warning { color: red; background: transparent; }
   .note, .warning { font-weight: bolder; font-style: italic; }
   .note em, .warning em, .note i, .warning i { font-style: normal; }
   p.note, div.note { padding: 0.5em 2em; }
   span.note { padding: 0 2em; }
   .note p:first-child, .warning p:first-child { margin-top: 0; }
   .note p:last-child, .warning p:last-child { margin-bottom: 0; }
   .warning:before { font-style: normal; }
   p.note:before { content: 'Note: '; }
   p.warning:before { content: '\26A0 Warning! '; }

   .bookkeeping:before { display: block; content: 'Bookkeeping details'; font-weight: bolder; font-style: italic; }
   .bookkeeping { font-size: 0.8em; margin: 2em 0; }
   .bookkeeping p { margin: 0.5em 2em; display: list-item; list-style: square; }
   .bookkeeping dt { margin: 0.5em 2em 0; }
   .bookkeeping dd { margin: 0 3em 0.5em; }

   h4 { position: relative; z-index: 3; }
   h4 + .element, h4 + div + .element { margin-top: -2.5em; padding-top: 2em; }
   .element {
     background: #EEEEFF;
     color: black;
     margin: 0 0 1em 0.15em;
     padding: 0 1em 0.25em 0.75em;
     border-left: solid #9999FF 0.25em;
     position: relative;
     z-index: 1;
   }
   .element:before {
     position: absolute;
     z-index: 2;
     top: 0;
     left: -1.15em;
     height: 2em;
     width: 0.9em;
     background: #EEEEFF;
     content: ' ';
     border-style: none none solid solid;
     border-color: #9999FF;
     border-width: 0.25em;
   }

   .example { display: block; color: #222222; background: #FCFCFC; border-left: double; margin-left: 2em; padding-left: 1em; }
   td > .example:only-child { margin: 0 0 0 0.1em; }

   ul.domTree, ul.domTree ul { padding: 0 0 0 1em; margin: 0; }
   ul.domTree li { padding: 0; margin: 0; list-style: none; position: relative; }
   ul.domTree li li { list-style: none; }
   ul.domTree li:first-child::before { position: absolute; top: 0; height: 0.6em; left: -0.75em; width: 0.5em; border-style: none none solid solid; content: ''; border-width: 0.1em; }
   ul.domTree li:not(:last-child)::after { position: absolute; top: 0; bottom: -0.6em; left: -0.75em; width: 0.5em; border-style: none none solid solid; content: ''; border-width: 0.1em; }
   ul.domTree span { font-style: italic; font-family: serif; }
   ul.domTree .t1 code { color: purple; font-weight: bold; }
   ul.domTree .t2 { font-style: normal; font-family: monospace; }
   ul.domTree .t2 .name { color: black; font-weight: bold; }
   ul.domTree .t2 .value { color: blue; font-weight: normal; }
   ul.domTree .t3 code, .domTree .t4 code, .domTree .t5 code { color: gray; }
   ul.domTree .t7 code, .domTree .t8 code { color: green; }
   ul.domTree .t10 code { color: teal; }

   body.dfnEnabled dfn { cursor: pointer; }
   .dfnPanel {
     display: inline;
     position: absolute;
     z-index: 10;
     height: auto;
     width: auto;
     padding: 0.5em 0.75em;
     font: small sans-serif, Droid Sans Fallback;
     background: #DDDDDD;
     color: black;
     border: outset 0.2em;
   }
   .dfnPanel * { margin: 0; padding: 0; font: inherit; text-indent: 0; }
   .dfnPanel :link, .dfnPanel :visited { color: black; }
   .dfnPanel p { font-weight: bolder; }
   .dfnPanel * + p { margin-top: 0.25em; }
   .dfnPanel li { list-style-position: inside; }

   #configUI { position: absolute; z-index: 20; top: 10em; right: 1em; width: 11em; font-size: small; }
   #configUI p { margin: 0.5em 0; padding: 0.3em; background: #EEEEEE; color: black; border: inset thin; }
   #configUI p label { display: block; }
   #configUI #updateUI, #configUI .loginUI { text-align: center; }
   #configUI input[type=button] { display: block; margin: auto; }

   fieldset { margin: 1em; padding: 0.5em 1em; }
   fieldset > legend + * { margin-top: 0; }
   fieldset > :last-child { margin-bottom: 0; }
   fieldset p { margin: 0.5em 0; }

   .stability {
     position: fixed;
     bottom: 0;
     left: 0; right: 0;
     margin: 0 auto 0 auto;
     width: 50%;
     background: maroon; color: yellow;
     -webkit-border-radius: 1em 1em 0 0;
     -moz-border-radius: 1em 1em 0 0;
     border-radius: 1em 1em 0 0;
     -moz-box-shadow: 0 0 1em #500;
     -webkit-box-shadow: 0 0 1em #500;
     box-shadow: 0 0 1em red;
     padding: 0.5em 1em;
     text-align: center;
   }
   .stability strong {
     display: block;
   }
   .stability input {
     appearance: none; margin: 0; border: 0; padding: 0.25em 0.5em; background: transparent; color: black;
     position: absolute; top: -0.5em; right: 0; font: 1.25em sans-serif; text-align: center;
   }
   .stability input:hover {
     color: white;
     text-shadow: 0 0 2px black;
   }
   .stability input:active {
     padding: 0.3em 0.45em 0.2em 0.55em;
   }
   .stability :link, .stability :visited,
   .stability :link:hover, .stability :visited:hover {
     background: transparent;
     color: white;
   }

  </style><link href="http://www.w3.org/StyleSheets/TR/W3C-WD" rel="stylesheet" type="text/css"><meta content="noindex" name="robots"><style type="text/css">

   .applies thead th > * { display: block; }
   .applies thead code { display: block; }
   .applies tbody th { whitespace: nowrap; }
   .applies td { text-align: center; }
   .applies .yes { background: yellow; }

   .matrix, .matrix td { border: hidden; text-align: right; }
   .matrix { margin-left: 2em; }

   .dice-example { border-collapse: collapse; border-style: hidden solid solid hidden; border-width: thin; margin-left: 3em; }
   .dice-example caption { width: 30em; font-size: smaller; font-style: italic; padding: 0.75em 0; text-align: left; }
   .dice-example td, .dice-example th { border: solid thin; width: 1.35em; height: 1.05em; text-align: center; padding: 0; }

   td.eg { border-width: thin; text-align: center; }

   #table-example-1 { border: solid thin; border-collapse: collapse; margin-left: 3em; }
   #table-example-1 * { font-family: "Essays1743", serif; line-height: 1.01em; }
   #table-example-1 caption { padding-bottom: 0.5em; }
   #table-example-1 thead, #table-example-1 tbody { border: none; }
   #table-example-1 th, #table-example-1 td { border: solid thin; }
   #table-example-1 th { font-weight: normal; }
   #table-example-1 td { border-style: none solid; vertical-align: top; }
   #table-example-1 th { padding: 0.5em; vertical-align: middle; text-align: center; }
   #table-example-1 tbody tr:first-child td { padding-top: 0.5em; }
   #table-example-1 tbody tr:last-child td { padding-bottom: 1.5em; }
   #table-example-1 tbody td:first-child { padding-left: 2.5em; padding-right: 0; width: 9em; }
   #table-example-1 tbody td:first-child::after { content: leader(". "); }
   #table-example-1 tbody td { padding-left: 2em; padding-right: 2em; }
   #table-example-1 tbody td:first-child + td { width: 10em; }
   #table-example-1 tbody td:first-child + td ~ td { width: 2.5em; }
   #table-example-1 tbody td:first-child + td + td + td ~ td { width: 1.25em; }

   .apple-table-examples { border: none; border-collapse: separate; border-spacing: 1.5em 0em; width: 40em; margin-left: 3em; }
   .apple-table-examples * { font-family: "Times", serif; }
   .apple-table-examples td, .apple-table-examples th { border: none; white-space: nowrap; padding-top: 0; padding-bottom: 0; }
   .apple-table-examples tbody th:first-child { border-left: none; width: 100%; }
   .apple-table-examples thead th:first-child ~ th { font-size: smaller; font-weight: bolder; border-bottom: solid 2px; text-align: center; }
   .apple-table-examples tbody th::after, .apple-table-examples tfoot th::after { content: leader(". ") }
   .apple-table-examples tbody th, .apple-table-examples tfoot th { font: inherit; text-align: left; }
   .apple-table-examples td { text-align: right; vertical-align: top; }
   .apple-table-examples.e1 tbody tr:last-child td { border-bottom: solid 1px; }
   .apple-table-examples.e1 tbody + tbody tr:last-child td { border-bottom: double 3px; }
   .apple-table-examples.e2 th[scope=row] { padding-left: 1em; }
   .apple-table-examples sup { line-height: 0; }

   .details-example img { vertical-align: top; }

   #base64-table {
     white-space: nowrap;
     font-size: 0.6em;
     column-width: 6em;
     column-count: 5;
     column-gap: 1em;
     -moz-column-width: 6em;
     -moz-column-count: 5;
     -moz-column-gap: 1em;
     -webkit-column-width: 6em;
     -webkit-column-count: 5;
     -webkit-column-gap: 1em;
   }
   #base64-table thead { display: none; }
   #base64-table * { border: none; }
   #base64-table tbody td:first-child:after { content: ':'; }
   #base64-table tbody td:last-child { text-align: right; }

   #named-character-references-table {
     white-space: nowrap;
     font-size: 0.6em;
     column-width: 30em;
     column-gap: 1em;
     -moz-column-width: 30em;
     -moz-column-gap: 1em;
     -webkit-column-width: 30em;
     -webkit-column-gap: 1em;
   }
   #named-character-references-table > table > tbody > tr > td:first-child + td,
   #named-character-references-table > table > tbody > tr > td:last-child { text-align: center; }
   #named-character-references-table > table > tbody > tr > td:last-child:hover > span { position: absolute; top: auto; left: auto; margin-left: 0.5em; line-height: 1.2; font-size: 5em; border: outset; padding: 0.25em 0.5em; background: white; width: 1.25em; height: auto; text-align: center; }
   #named-character-references-table > table > tbody > tr#entity-CounterClockwiseContourIntegral > td:first-child { font-size: 0.5em; }

   .glyph.control { color: red; }

   @font-face {
     font-family: 'Essays1743';
     src: url('http://www.whatwg.org/specs/web-apps/current-work/fonts/Essays1743.ttf');
   }
   @font-face {
     font-family: 'Essays1743';
     font-weight: bold;
     src: url('http://www.whatwg.org/specs/web-apps/current-work/fonts/Essays1743-Bold.ttf');
   }
   @font-face {
     font-family: 'Essays1743';
     font-style: italic;
     src: url('http://www.whatwg.org/specs/web-apps/current-work/fonts/Essays1743-Italic.ttf');
   }
   @font-face {
     font-family: 'Essays1743';
     font-style: italic;
     font-weight: bold;
     src: url('http://www.whatwg.org/specs/web-apps/current-work/fonts/Essays1743-BoldItalic.ttf');
   }

  </style><link href="data:text/css," id="complete" rel="stylesheet" title="Complete specification"><link href="data:text/css,.impl%20%7B%20display:%20none;%20%7D%0Ahtml%20%7B%20border:%20solid%20yellow;%20%7D%20.domintro:before%20%7B%20display:%20none;%20%7D" id="author" rel="alternate stylesheet" title="Author documentation only"><link href="data:text/css,.impl%20%7B%20background:%20%23FFEEEE;%20%7D%20.domintro:before%20%7B%20background:%20%23FFEEEE;%20%7D" id="highlight" rel="alternate stylesheet" title="Highlight implementation requirements"><script type="text/javascript">
   function getCookie(name) {
     var params = location.search.substr(1).split("&");
     for (var index = 0; index < params.length; index++) {
       if (params[index] == name)
         return "1";
       var data = params[index].split("=");
       if (data[0] == name)
         return unescape(data[1]);
     }
     var cookies = document.cookie.split("; ");
     for (var index = 0; index < cookies.length; index++) {
       var data = cookies[index].split("=");
       if (data[0] == name)
         return unescape(data[1]);
     }
     return null;
   }
  </script>
  <script src="link-fixup.js"></script>
  <link href="the-track-element.html" title="4.8.9 The track element" rel="prev">
  <link href="index.html#contents" title="Table of contents" rel="contents">
  <link href="the-canvas-element.html" title="4.8.11 The canvas element" rel="next">
  </head><body onload="fixBrokenLink();" class="split chapter"><div class="head" id="head">
   <p><a href="http://www.w3.org/"><img alt="W3C" height="48" src="http://www.w3.org/Icons/w3c_home" width="72"></a></p>

   <h1>Media Recording API</h1>
   <h2>December 20, 2012</h2>
 
   <dt>This version:</dt>
      <dd><a href="@@@">@@@</a></dd>
      <dt>Latest published version:</dt>
      <dd><a href="@@@">@@@</a></dd> 
   <dt>Editors:</dt>
    <dd><span>Jim Barnett</span>, Genesys</dd>
<dd><span>Travis Leithead</span>, Microsoft</dd> 
  </dl>
  
  <section id="sotd" class="introductory"><h2>Status of This Document</h2>
  
    
      
        <p>
          <em>This section describes the status of this document at the time of its publication. Other
          documents may supersede this document. A list of current <acronym title="World Wide Web Consortium">W3C</acronym> publications and the latest revision
          of this technical report can be found in the <a href="http://www.w3.org/TR/"><acronym title="World Wide Web Consortium">W3C</acronym> technical reports
          index</a> at http://www.w3.org/TR/.</em>
        </p>
        
    <p>This document is not complete. It is subject to major changes and, while
    early experimentations are encouraged, it is therefore not intended for
    implementation. 
    The Media Capture Task Force expects this specification to evolve
    significantly based on:</p>

    <ul>
      <li>Privacy issues that arise when capturing media.</li>

      <li>Technical discussions within the task force.</li>

      <li>Experience gained through early experimentations.</li>

      <li>Feedback received from other groups and individuals.</li>
    </ul>
  
        <p>
          This document was published by the <a href="http://www.w3.org/2011/04/webrtc/">Web Real-Time Communication Working Group</a> as an Editor's Draft.
          
          If you wish to make comments regarding this document, please send them to 
          <a href="mailto:public-media-capture@w3.org">public-media-capture@w3.org</a> 
          (<a href="mailto:public-media-capture-request@w3.org?subject=subscribe">subscribe</a>,
          <a href="http://lists.w3.org/Archives/Public/public-media-capture/">archives</a>).
          
          
          All feedback is welcome.
        </p>
        
          <p>
            Publication as an Editor's Draft does not imply endorsement by the <acronym title="World Wide Web Consortium">W3C</acronym> Membership.
            This is a draft document and may be updated, replaced or obsoleted by other documents at 
            any time. It is inappropriate to cite this document as other than work in progress.
          </p>
        
        
        <p>
          
            This document was produced by a group operating under the 
            <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/">5 February 2004 <acronym title="World Wide Web Consortium">W3C</acronym> Patent Policy</a>.
          
          
          
            
              <acronym title="World Wide Web Consortium">W3C</acronym> maintains a public list of any patent disclosures (<a href="http://www.w3.org/2004/01/pp-impl/47318/status" rel="disclosure">Web Real-Time Communication Working Group</a>, <a href="http://www.w3.org/2004/01/pp-impl/43696/status" rel="disclosure">Device APIs Working Group</a>)
            
            made in connection with the deliverables of the group; that page also includes instructions for 
            disclosing a patent. An individual who has actual knowledge of a patent which the individual believes contains
            <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential">Essential Claim(s)</a> must disclose the
            information in accordance with <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure">section
            6 of the <acronym title="World Wide Web Consortium">W3C</acronym> Patent Policy</a>.
          
          
        </p>
        
      
    
  
</section>
  

<section id="overview"><h2><span class="secno">1.0 </span>Overview</h2>
  <p>This proposal attempts to make basic recording very simple, while still allowing for more complex use cases.  In the simplest case,
  	the application instatiates the MediaRecorder object, calls record() and then calls stopRecord() or waits for the MediaStream to be ended.  The contents of the recording
  	will be made available in the platform's default encoding via the dataavailable event.  Functions are available to query
  	the platform's available set of encodings, and to select the desired ones if the author wishes.  The application can also choose 
  	how much data it wants to receive at one time.  By default a Blob containing the entire recording is returned when
  	the recording finishes.  However the application can choose to receive smaller buffers of data at regular intervals.  </p>
 </section>
 
 <section id="MediaRecorderAPI"><h2><span class="secno">2.0 </span>Media Recorder API</h2>

       <pre class="idl"><span class="idlInterface" id="idl-def-MediaRecorder">
[<span class="extAttr">Constructor (MediaStream stream)</span>]
interface <span class="idlInterfaceID">MediaRecorder</span> : <span class="idlSuperclass"><a>EventTarget </a></span> {

<span class="idlAttribute">    readonly attribute <span class="idlAttrType"><a class="idlType" href="widl-mediaStream"><code>MediaStream</code></a></span>    <span class="idlAttrName"><a href="#widl-mediaStream">mediaStream</a></span>;</span>
<span class="idlAttribute">    readonly attribute <span class="idlAttrType"><a class="idlType" href="#idl-def-RecordingState"><code>RecordingState</code></a></span> <span class="idlAttrName"><a href="#widl-recordingstate">state</a></span>;</span>
<span class="idlAttribute">             attribute <span class="idlAttrType"><a class="idlType" href=""><code>EventHandler</code></a></span>   <span class="idlAttrName"><a href="#widl-onrecording">onrecording</a></span>;</span>
<span class="idlAttribute">             attribute <span class="idlAttrType"><a class="idlType" href=""><code>EventHandler</code></a></span>   <span class="idlAttrName"><a href="#widl-onstoprecording">onstoprecording</a></span>;</span>
<span class="idlAttribute">             attribute <span class="idlAttrType"><a class="idlType" href=""><code>EventHandler</code></a></span>   <span class="idlAttrName"><a href="#widl-ondataavailable">ondataavailable</a></span>;</span>
<span class="idlAttribute">             attribute <span class="idlAttrType"><a class="idlType" href=""><code>EventHandler</code></a></span>   <span class="idlAttrName"><a href="#widl-onpause">onpause</a></span>;</span>
<span class="idlAttribute">             attribute <span class="idlAttrType"><a class="idlType" href=""><code>EventHandler</code></a></span>   <span class="idlAttrName"><a href="#widl-onresume">onresume</a></span>;</span>
<span class="idlAttribute">             attribute <span class="idlAttrType"><a class="idlType" href=""><code>EventHandler</code></a></span>   <span class="idlAttrName"><a href="#widl-onmutetrackrecording">onmutetrack</a></span>;</span>
<span class="idlAttribute">             attribute <span class="idlAttrType"><a class="idlType" href=""><code>EventHandler</code></a></span>   <span class="idlAttrName"><a href="#widl-onunmutetrackrecording">onunmutetrack</a></span>;</span>
<span class="idlAttribute">             attribute <span class="idlAttrType"><a class="idlType" href=""><code>EventHandler</code></a></span>   <span class="idlAttrName"><a href="#widl-onphoto">onphoto</a></span>;</span>
<span class="idlAttribute">             attribute <span class="idlAttrType"><a class="idlType" href=""><code>EventHandler</code></a></span>   <span class="idlAttrName"><a href="#widl-onrecordingerror">onrecordingerror</a></span>;</span>
<span class="idlAttribute">             attribute <span class="idlAttrType"><a class="idlType" href=""><code>EventHandler</code></a></span>   <span class="idlAttrName"><a href="#widl-onrecordingwarning">onrecordingwarning</a></span>;</span>
<span class="idlMethod">    <span class="idlMethType"><a>void</a></span>                              <span class="idlMethName"><a href="#widl-record">record</a></span> (<span class="idlParam">optional <span class="idlParamType">long</span> <span class="idlParamName">timeSlice</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType"><a>void</a></span>                              <span class="idlMethName"><a href="#widl-stoprecording">stopRecording</a></span> ();</span>
<span class="idlMethod">    <span class="idlMethType"><a>void</a></span>                              <span class="idlMethName"><a href="#widl-pause">pause</a></span>();</span>
<span class="idlMethod">    <span class="idlMethType"><a>void</a></span>                              <span class="idlMethName"><a href="#widl-resume">resume</a></span>();</span>
<span class="idlMethod">    <span class="idlMethType"><a>void</a></span>                              <span class="idlMethName"><a href="#widl-mutetrack">muteTrack</a></span>(<span class="idlParamType">DOMString</span> <span class="idlParamName">trackID</span>);</span>
<span class="idlMethod">    <span class="idlMethType"><a>void</a></span>                              <span class="idlMethName"><a href="#widl-unmuteTrack">unmuteTrack</a></span>(<span class="idlParamType">DOMString</span> <span class="idlParamName">trackID</span>);</span>
<span class="idlMethod">    <span class="idlMethType"><a>void</a></span>                              <span class="idlMethName"><a href="#widl-takePhoto">takePhoto</a></span>(<span class="idlParamType">DOMString</span> <span class="idlParamName">trackID</span>);</span>
<span class="idlMethod">    <span class="idlMethType"><a>void</a></span>                              <span class="idlMethName"><a href="#widl-requestData">requestData</a></span>();</span>
<span class="idlMethod">    <span class="idlMethType"><a href="#widl-dictionary-availablerecordingformats">AvailableRecordingFormats</a></span>         <span class="idlMethName"><a href="#widl-getrecordingoptions">getRecordingOptions</a></span> ();</span>
<span class="idlMethod">    <span class="idlMethType"><a>void</a></span>                              <span class="idlMethName"><a href="#widl-setrecordingoptions">setRecordingOptions</a></span> (<span class="idlParam"><span class="idlParamType"><a class=idlType href="#widl-dictionaryrecordingformat">RecordingFormat</a></span> <span class="idlParamName">RequestedFormats</span>);</span>
};</span></pre>

<p>The <dfn id="dom-mediarecorder"> <code>MediaRecorder()</code></dfn>
      constructor takes one argument which
      <em title="must" class="rfc2119">must</em> be of type <code>MediaStream</code></code> (see <a href="#bib-mediacapture" class="bibref">Media-Capture)</a>. When the constructor
      is invoked, the UA <em title="must" class="rfc2119">must</em> construct a new <a class="idlType" href="#idl-def-MediaRecorder"><code>MediaRecorder</code></a></code> object,
      	 set its <a href="#widl-mediastream">mediaStream</a> attribute to be the provided MediaStream, set its <a href="#widl-recordingstate">state</a> attribute to 'inactive'
      	 and return the object.</p>

<section id="attributes-1"><h3><span class="secno">2.1 </span>Attributes</h3>
		<dl class="attributes"><dt id="widl-mediaStream"><code>mediaStream</code> of type <span class="idlAttrType"><a class="idlType" href=""><code>MediaStream</code></a></span>, readonly</dt><dd>
          <p>The MediaStream passed in to the constructor. </p>
        </dd></dl>
	<dl class="attributes"><dt id="widl-recordingstate"><code>state</code> of type <span class="idlAttrType"><a class="idlType" href="#idl-def-RecordingState"><code>Recordingstate</code></a></span>, readonly</dt><dd>
          <p>The current state of the MediaRecorder object. </p>
        </dd></dl>
  <dl class="attributes"><dt id="widl-onrecording"><code>onrecording</code> of type <span class="idlAttrType"><a class="idlType" href=""><code>EventHandler</code></a></span></dt><dd>
          <p>Called to handle the recording event.</p>
        </dd></dl>
  <dl class="attributes"><dt id="widl-onstoprecording"><code>onstoprecording</code> of type <span class="idlAttrType"><a class="idlType" href=""><code>EventHandler</code></a></span></dt><dd>
          <p>Called to handle the stoprecording event.</p>
        </dd></dl>
 
<dl class="attributes"><dt id="widl-ondataavailable"><code>ondataavailable</code> of type <span class="idlAttrType"><a class="idlType" href=""><code>EventHandler</code></a></span></dt><dd>
          <p>Called to handle the dataavailable event.  Note that the Blob (see <cite><a href="#bib-FILE-API" class="bibref">FILEAPI</a></cite>) of recorded data is contained in this event and can
          	be accessed via the 'detail' attribute.</p>
        </dd></dl> 

<dl class="attributes"><dt id="widl-onpause"><code>onpause</code> of type <span class="idlAttrType"><a class="idlType" href=""><code>EventHandler</code></a></span></dt><dd>
          <p>Called to handle the pause event. </p>
        </dd></dl> 
<dl class="attributes"><dt id="widl-onresume"><code>onresume</code> of type <span class="idlAttrType"><a class="idlType" href=""><code>EventHandler</code></a></span></dt><dd>
          <p>Called to handle the resume event.  </p>
        </dd></dl> 
<dl class="attributes"><dt id="widl-onmutetrackrecording"><code>onmutetrackrecording</code> of type <span class="idlAttrType"><a class="idlType" href=""><code>EventHandler</code></a></span></dt><dd>
          <p>Called to handle the mutetrackrecording event.</p>
        </dd></dl>
        
<dl class="attributes"><dt id="widl-onunmutetrackrecording"><code>onunmutetrackrecording</code> of type <span class="idlAttrType"><a class="idlType" href=""><code>EventHandler</code></a></span></dt><dd>
          <p>Called to handle the unmutetrackrecording event.  </p>
        </dd></dl>  
<dl class="attributes"><dt id="widl-onphoto"><code>onphoto</code> of type <span class="idlAttrType"><a class="idlType" href=""><code>EventHandler</code></a></span></dt><dd>
          <p>Called to handle the photo event.  The photo event returns a photo (as a Blob) in a compressed format (for example: PNG/JPEG) rather than a 
                            raw ImageData object due to the expected large, uncompressed size of the resulting photos.</p>
        </dd></dl>  
<dl class="attributes"><dt id="widl-onrecordingerror"><code>onrecordingerror</code> of type <span class="idlAttrType"><a class="idlType" href=""><code>EventHandler</code></a></span></dt><dd>
          <p>Called to handle the recordingerror event. </p>
        </dd></dl> 
<dl class="attributes"><dt id="widl-onrecordingwarning"><code>onrecordingwarning</code> of type <span class="idlAttrType"><a class="idlType" href=""><code>EventHandler</code></a></span></dt><dd>
          <p>Called to handle the recordingwarning event. </p>
        </dd></dl> 
              
        </section>
        
<section id="methods-1"><h3><span class="secno">2.2 </span>Methods</h3>
	<dl class="methods"><dt id="widl-record"><code>record</code></dt><dd>
		<p><p>When a <code><a class="idlType" href="#idl-def-MediaRecorder"><code>MediaRecorder</code></a></code> object’s <code>record()</code> method is invoked,
			then, if the <a href="#widl-recordingstate">state</a> is not "inactive", the UA <em title="must" class="rfc2119"> must </em>
				raise an <code>INVALID_STATE</code> 
			exception and return immediately.  Otherwise, it <em title="must" class="rfc2119">must</em> queue a task, using the DOM manipulation task source, that runs the following steps:</p>
		<ol>

				<li>Set <a href="#widl-recordingstate">state</a> to 'recording' and wait until media
					becomes available from <a href="#widl-mediaStream">mediaStream</a>.</li>
			<li>Once data becomes available raise a <code>recording</code>event and start gathering the 
				data into a Blob (see <cite><a href="#bib-FILE-API" class="bibref">FILEAPI</a></cite>). </li>
		<li>If the <code>timeSlice</code> argument has been provided, then once <code>timeSlice</code>
			milliseconds of data have been colleced, raise a <code>dataavailable</code> event containing
			the Blob of collected data, and start gathering a new Blob of data.  Otherwise (if <code>timeSlice</code>
			has not been provided), continue gathering data into the original Blob.</li>
			<li>When the <a href="#idl-mediaStream">mediaStream</a> is ended set <a href="widl-recoding">recording</a>
					to 'false' and stop gathering data.
					<li>Then  raise a <code>dataavailable</code> event containing the Blob of data.</li>
					<li>Finally, raise a <code>stoprecording</code> event.</li> 
			</ol>
			<p>Note that <a href="#widl-stoprecording"><code>stopRecording()</code></a>,
				<a href="#widl-requestData"><code>requestData()</code></a>, <a href="#widl-pause"><code>pause</code></a>,
				and <a href="#widl-mutetrack"><code>muteTrack</code></a> also affect the recording behavior.</p>
					<br>
			<p>The UA <em title="must" class="rfc2119">must</em> record the MediaStream
			in such a way that the original Tracks can be retrieved at playback time.  If any Track within the
			MediaStream is muted at any time (i.e., if its <code>readyState</code> is set to <code>muted</code>), the UA
			<em title="must" class="rfc2119">must</em> insert black frames or silence until the Track is unmuted. If the UA is 
			unable to start recording or at any point is unable to contine recording, it <em title="must" class="rfc2119">must</em> raise 
			a <code>recordingerror</code> event, follwowed by a <code>dataavailable</code> event containing
			the Blob it has gathered, follwed by the <code>stoprecording</code> event.    
		</p>
				  
	</dd></dl>
<dl class="methods"><dt id="widl-stoprecording"><code>stopRecording</code></dt><dd>
	<p><p>When a <code><a class="idlType" href="#idl-def-MediaRecorder"><code>MediaRecorder</code></a></code> object’s <code>stopRecording</code> method is invoked,
          then if <a href="#widl-recordingstate"><code>state</code></a> is "inactive", the user agent <em title="must" class="rfc2119">must</em> 
          raise an INVALID_STATE exception and return immediately.  Otherwise it <em title="must" class="rfc2119">must</em> 
          queue a task, using the DOM manipulation task source, that runs the following steps:</p>
		<ol>
			
			<li>Set <a href="#widl-recordingstate">state</a> to 'inactive' and stop gathering data. </li>
			<li>Raise a <code>dataavailable</code> event containing the Blob of data that has been gathered.</li>
			<li>Raise a <code>recordingdone</code> event</li>
				
			</ol>
		</dd></dl>
	
<dl class="methods"><dt id="widl-requestData"><code>requestData</code></dt><dd>
	<p>When a <code><a class="idlType" href="#idl-def-MediaRecorder"><code>MediaRecorder</code></a></code> object’s <code>requestData()</code></dfn> method is invoked,
	then if <a href="#widl-recordingstate"><code>state</code></a> is not "recording"
          the user agent <em title="must" class="rfc2119">must</em> raise an INVALID_STATE exception
          and return immediately.  Otherwise it <em title="must" class="rfc2119">must</em>
          queue a task, using the DOM manipulation task source, that runs the following steps:</p>
		<ol>
		<li>Raise a <code>dataavailable</code> event containing the current Blob of saved data.</li>
		<li>Creat a new Blob and gather subsequent data into it.</li>
	</ol>
		</dd></dl>

<dl class="methods"><dt id="widl-pause"><code>pause</code></dt><dd>
	<p>When a <code><a class="idlType" href="#idl-def-MediaRecorder"><code>MediaRecorder</code></a></code> object’s <code>pause()</code></dfn> method is invoked,
	then if <a href="#widl-recordingstate"><code>state</code></a> is  "inactive"
          the user agent <em title="must" class="rfc2119">must</em> raise an INVALID_STATE exception
          and return immediately.  Otherwise it <em title="must" class="rfc2119">must</em>
          queue a task, using the DOM manipulation task source, that runs the following steps:</p>
		<ol>
		<li>Set <a href="#widl-state"><code>state</code></a> to "paused".</li>
		<li>Stop gathering data into its current Blob (but keep the Blob available so that 
			recording can be resumed in the future).</li>
			<li>Raise a <code>pause</code> event </li>
	</ol>
		</dd></dl>	
<dl class="methods"><dt id="widl-resume"><code>resume</code></dt><dd>
	<p>When a <code><a class="idlType" href="#idl-def-MediaRecorder"><code>MediaRecorder</code></a></code> object’s <code>resume()</code></dfn> method is invoked,
	then if <a href="#widl-recordingstate"><code>state</code></a> is  "inactive"
          the user agent <em title="must" class="rfc2119">must</em> raise an INVALID_STATE exception
          and return immediately.  Otherwise it <em title="must" class="rfc2119">must</em>
          queue a task, using the DOM manipulation task source, that runs the following steps:</p>
		<ol>
		<li>Set <a href="#widl-state"><code>state</code></a> to "recording".</li>
		<li>Resume (or continue) gathering data into its current Blob.</li>
		<li>Raise a <code>resume</code> event.</li>
	</ol>
		</dd></dl>	
<dl class="methods"><dt id="widl-mutetrack"><code>muteTrack</code></dt><dd>
		<p>When a <code><a class="idlType" href="#idl-def-MediaRecorder"><code>MediaRecorder</code></a></code> object’s <code>muteTrack()</code></dfn> method is invoked,
	then if <a href="#widl-recordingstate"><code>state</code></a> is not "recording"
          the user agent <em title="must" class="rfc2119">must</em> raise an INVALID_STATE exception
          and return immediately.  Otherwise if the <code>trackID</code> provided is not the 
          <code>id</code> of a Track object in <code>mediaStream</code>'s <code>audioTrackList</code>
          or <code>videoTrackList</code> it <em title="must" class="rfc2119">must</em> raise an INVALID_TRACK_ID exception
          and return immediately.  Otherwise it <em title="must" class="rfc2119">must</em>
          queue a task, using the DOM manipulation task source, that runs the following steps:</p>
		<ol>
		<li>If the specified Track is a video track, begin inserting black frames into the Blob
			in place of any data coming from the underlying source.  Otherwise (the Track is an audio track)
			insert silence into the Blob in place of any data coming from the underlying source.</li>
			<li>Raise a <code>mutetrackrecording</code> event.</li>
	</ol>
		</dd></dl>	
<dl class="methods"><dt id="widl-unmutetrack"><code>unmuteTrack</code></dt><dd>
	<p>When a <code><a class="idlType" href="#idl-def-MediaRecorder"><code>MediaRecorder</code></a></code> object’s <code>unmuteTrack()</code></dfn> method is invoked,
	then if <a href="#widl-recordingstate"><code>state</code></a> is not "recording",
          the user agent <em title="must" class="rfc2119">must</em> raise an INVALID_STATE exception
          and return immediately. Otherwise if the <code>trackID</code> provided is not the 
          <code>id</code> of a Track object in <code>mediaStream</code>'s <code>audioTrackList</code>
          or <code>videoTrackList</code> it <em title="must" class="rfc2119">must</em> raise an INVALID_TRACK_ID exception
          and return immediately. Otherwise it <em title="must" class="rfc2119">must</em>
          queue a task, using the DOM manipulation task source, that runs the following steps:</p>
		<ol>
			<li>Until such time as data is available for this Track from the underlying media source,
				 insert black frames (for a video track) or silence (for an audio track) into the current Blob. </li>
		<li>Once data is available for this Track from the underlying media source, start collecting
			it into the current Blob. </li>
	 <li>Raise an <code>unmutetrackrecording</code> event.</li>
		</dd></dl>
		
<dl class="methods"><dt id="widl-takephoto"><code>takePhoto</code></dt><dd>
	<p>When a <code><a class="idlType" href="#idl-def-MediaRecorder"><code>MediaRecorder</code></a></code> object’s <code>takePhoto()</code></dfn> method is invoked,
	then if <a href="#widl-recordingstate"><code>state</code></a> is not "recording",
          the user agent <em title="must" class="rfc2119">must</em> raise an INVALID_STATE exception
          and return immediately. Otherwise if the <code>trackID</code> provided is not the 
          <code>id</code> of a Track object in <code>mediaStream</code>'s  <code>videoTrackList</code>
          with a source type of "photo-camera", the UA <em title="must" class="rfc2119">must</em> raise an INVALID_TRACK_ID exception
          and return immediately. Otherwise it <em title="must" class="rfc2119">must</em>
          queue a task, using the DOM manipulation task source, that runs the following steps:</p>
		<ol>
			<li>Gather data from the Track into a Blob containing a single still image. The method of doing
				this will depend on the underlying device.  Some devices may just do a frame grab, while others
				may temporarilly stop streaming data, reconfigure themselves with the appropriate photo settings, take the photo,
				and then resume streaming.  In this case, the stopping and restarting of streaming <em title="should" class="rfc2119">should</em>
				cause <code>mute</code> and <code>unmute</code> events to fire on the Track in question.  </li>
	 <li>Raise an <code>photo</code> event containing the Blob.</li>
		</dd></dl>
				
<dl class="methods"><dt id="widl-getrecordingoptions"><code>getRecordingOptions</code></dt><dd>
		<p><p>When a <code><a class="idlType" href="#idl-def-MediaRecorder"><code>MediaRecorder</code></a></code> object’s <code>getRecordingOptions()</code></dfn> method is invoked,
          the user agent <em title="must" class="rfc2119">must </em>return a 
          	<a href="#widl-dictionary-availablerecordingformats"</a>availableRecordingFormats</a> structure
          containing the set of recording formats that it supports.</p>
		</dd></dl>
	
<dl class="methods"><dt id="widl-setrecordingoptions"><code>setRecordingOptions</code></dt><dd>
		<p>When a <code><a class="idlType" href="#idl-def-MediaRecorder">
			<code>MediaRecorder</code></a></code> object’s <code>setRecordingOptions()</code> method is invoked,
				then if <href ref="#widl-recordingstate"><code>state</code></href> is not
					"inactive", the user agent <em title="must" class="rfc2119">must</em> raise an INVALID_STATE
					exception and return immediately.  Otherwise it <em title="must" class="rfc2119">must</em>
					run the following steps before returning:</p>
		<ol>
				<li>Let <em>encodings</em> be the current set of encodings that are specified
					to be used for recording by the MediaRecorder.  (If setRecordingOptions() has not yet been called, these will
					be the UA's defaults.)</li>
			<li>For each encoding format that is specified in the <code>requestedFormats</code> argument,
				if the UA does not support it, raise a UNSUPPORTED_OPTION exception, set <em>encodings</em>
				back to its value in step 2, and terminate these steps.  Otherwise
				replace the corresponding member of <em>encodings</em> with the specified value.</li>
			</ol>
		</dd></dl>

</section>

      <section id="recordingstate-enum">
        <h2><span class="secno">3.0 </span>RecordingState Enum</h2>

        <pre class="idl"><span class="idlEnum" id="idl-def-RecordingState">enum <span class="idlEnumID">RecordingState</span> {
    "<span class="idlEnumItem">inactive</span>",
    "<span class="idlEnumItem">recording</span>",
    "<span class="idlEnumItem">paused</span>",
};</span></pre>

<table class="simple"><tr><th colspan="2">Enumeration description</th></tr><tr><td><code>inactive</code></td><td>Recording is not occuring.  (Either it has not been started or it has been stopped.)</td></tr>
          <tr><td><code>recording</code></td><td>Recording has been started and he UA is capturing data.</td></tr>
          <tr><td><code>paused</code></td><td>Recording has been started, then paused, and not yet stopped or resumed.</td></tr>
	  	</table>
	  	
            <section id="blob-event">
                <h2><span class="secno">3.1 </span>BlobEvent</h2>

                <p><dfn id="dfn-blobevent">BlobEvent</dfn> interface</p>
                <pre class="idl"><span class="idlInterface" id="idl-def-BlobEvent">[<span class="extAttr">Constructor(DOMString type, optional BlobEventInit blobInitDict)</span>]
interface <span class="idlInterfaceID">BlobEvent</span> : <span class="idlSuperclass"><a>Event</a></span> {
<span class="idlAttribute">    readonly attribute <span class="idlAttrType"><a>Blob</a></span> <span class="idlAttrName"><a href="#widl-BlobEvent-data">data</a></span>;</span>
};</span></pre><section><h5 id="attributes-4">Attributes</h5><dl class="attributes"><dt id="widl-BlobEvent-data"><code>data</code> of type <span class="idlAttrType"><a>Blob</a></span>, readonly</dt><dd>Returns a Blob object whose type attribute indicates the encoding of the blob data. An implementation must
                        return a Blob in a format that is capable of being viewed in an HTML <code>&lt;img&gt;</code> tag.
                    </dd></dl></section>
            
                <p>BlobEventInit dictionary</p>
                <pre class="idl"><span class="idlDictionary" id="idl-def-BlobEventInit">dictionary <span class="idlDictionaryID">BlobEventInit</span> : <span class="idlSuperclass"><a>EventInit</a></span> {
<span class="idlMember">    <span class="idlMemberType"><a>Blob</a></span> <span class="idlMemberName"><a href="#widl-BlobEventInit-data">data</a></span>;</span>
};</span></pre><section><h5 id="dictionary-blobeventinit-members">Dictionary <a class="idlType" href="#idl-def-BlobEventInit"><code>BlobEventInit</code></a> Members</h5><dl class="dictionary-members"><dt id="widl-BlobEventInit-data"><code>data</code> of type <span class="idlMemberType"><a>Blob</a></span></dt><dd>A Blob object containing the data to deliver via this event.</dd></dl></section>
            </section>
            
<section id="widl-dictionary-availablerecordingformats"><h2><span class="secno">3.2 </span>Dictionary <code>AvailableRecordingFormats</code></h2>
      <pre class="idl"><span class="idlDictionary" id="">dictionary <span class="idlDictionaryID">AvailableRecordingFormats</span> {
<span class="idlMember">    <span class="idlMemberType"><a>sequence&lt;DOMString&gt;</a></span> <span class="idlMemberName"><a href="">containerEncodingFormats</a></span>;</span>
<span class="idlMember">    <span class="idlMemberType"><a>sequence&lt;DOMString&gt</a></span> <span class="idlMemberName"><a href="">audioEncodingFormats</a></span>;</span>
<span class="idlMember">    <span class="idlMemberType"><a>sequence&lt;DOMString&gt</a></span> <span class="idlMemberName"><a href="">videoEncodingFormats</a></span>;</span>
};</span></pre>
<dl class="attributes"><dt id="widl-containerencodingformats"><code>containerEncodingFormats</code> of type <span class="idlAttrType"><a class="idlType" href=""><code>sequence&lt;DOMtring&gt;</code></a></span></dt><dd>
          <p>A list of the container encoding formats that the platform supports.  </p>
        </dd></dl> 
<dl class="attributes"><dt id="widl-audioencodingformats"><code>audioEncodingFormats</code> of type <span class="idlAttrType"><a class="idlType" href=""><code>sequence&lt;DOMtring&gt;</code></a></span></dt><dd>
          <p>A list of the audio encoding formats that the platform supports.   </p>
        </dd></dl>  
<dl class="attributes"><dt id="widl-videoencodingformats"><code>videoEncodingFormats</code> of type <span class="idlAttrType"><a class="idlType" href=""><code>sequence&lt;DOMtring&gt;</code></a></span></dt><dd>
          <p>A list of the video encoding formats that the platform supports.  </p>
        </dd></dl> 
        
        <p>The UA <em title="must" class="rfc2119">must</em> be able to play back any encoding format that
        	it can record into.  The UA <em title="must" class="rfc2119">must</em> support a container format
        	capable of holding at least two video Tracks and two audio Tracks.  </p>
</section>

<section id="widl-dictionary-recordingformat"><h3><span class="secno">3.3 </span>Dictionary <a href="#idl-def-DataChannelInit" class="idlType"><code>RecordingFormat</code></a></h3>
      <pre class="idl"><span class="idlDictionary" id="">dictionary <span class="idlDictionaryID">RecordingFormat</span> {
<span class="idlMember">    <span class="idlMemberType">&lt;DOMString&gt;</span> <span class="idlMemberName"><a href="">containerEncodingFormat</a></span>;</span>
<span class="idlMember">    <span class="idlMemberType">&lt;DOMString&gt</span> <span class="idlMemberName"><a href="">audioEncodingFormat</a></span>;</span>
<span class="idlMember">    <span class="idlMemberType">&lt;DOMString&gt</span> <span class="idlMemberName"><a href="">videoEncodingFormat</a></span>;</span>
};</span></pre>
<dl class="attributes"><dt id="widl-containerencodingformat"><code>containerEncodingFormat</code> of type <span class="idlAttrType"><a class="idlType" href=""><code>&lt;DOMtring&gt;</code></a></span></dt><dd>
          <p>The container encoding format to use for recording.  If it is not specified, the platform default will be used. </p>
        </dd></dl> 
<dl class="attributes"><dt id="widl-audioencodingformat"><code>audioEncodingFormat</code> of type <span class="idlAttrType"><a class="idlType" href=""><code>&lt;DOMtring&gt;</code></a></span></dt><dd>
          <p>The audio encoding format to use for recording.  If it is not specified, the platform default will be used.  </p>
        </dd></dl>  
<dl class="attributes"><dt id="widl-videoencodingformat"><code>videoEncodingFormat</code> of type <span class="idlAttrType"><a class="idlType" href=""><code>&lt;DOMtring&gt;</code></a></span></dt><dd>
          <p>The video encoding format to use for recording.  If it is not specified, the platform default will be used.  </p>
        </dd></dl> 

</section>

   <section id="error-handling">
      <h2><span class="secno">4.0 </span>Error Handling</h2>

      <section id="general-principles">
        <h3><span class="secno">4.1 </span>General Principles</h3>

        <p>Errors are indicated in two ways: exceptions and objects passed to
        error callbacks. Both forms of error reporting <em title="must" class="rfc2119">must</em> provide an object
        of type <code>RecordingError</code>. An exception <em title="must" class="rfc2119">must</em> be thrown in the
        following cases:</p>

        <ul>
          <li>The type of any argument passed to a function did not match what
          was expected. An appropriate string from the
          <code>RecordingExceptionName</code> enum <em title="must" class="rfc2119">must</em> be used as the error
          name.</li>

          <li>A function call was made when the Recorder is in an
          invalid state, or a state in which that particular function is not
          allowed to be executed. In this case, the string
          <code>INVALID_STATE</code> <em title="must" class="rfc2119">must</em> be used as the error name.</li>
        </ul>

        <p>In all other cases, an error object <em title="must" class="rfc2119">must</em> be provided to the failure
        callback. The error name in the object provided <em title="must" class="rfc2119">must</em> be picked from
         the <code>RecordingErrorName</code>
        enums.  After raising the error, the UA <em title="must" class="rfc2119">must</em>
   	raise a  dataavailable event, containing any data that it has gathered,
   	and then a recordingdone event. The UA  <em title="may" class="rfc2119">may</em> set platform-specific
   	limits, such those for the minimum and maximum Blob size that it will support, or the number of 
   	Tracks it will record at once.  It <em title="must" class="rfc2119">must</em> signal a fatal
   	error if these limits are exceeded.  If a non-fatal error occurs during recording, the UA 
   	<em title="should" class="rfc2119">should</em> raise a recordingwarning event, with data indicating
   	the nature of the problem, and continue recording.</p>
      </section>

      <section id="recordingerror">
        <h3><span class="secno">4.2 </span>RecordingError</h3>

        <pre class="idl"><span class="idlInterface" id="idl-def-RecordingError">interface <span class="idlInterfaceID">RecordingError</span> {
<span class="idlAttribute">    readonly attribute <span class="idlAttrType"><a>DOMString</a></span>  <span class="idlAttrName"><a href="#widl-RecordingError-name">name</a></span>;</span>
<span class="idlAttribute">    readonly attribute <span class="idlAttrType"><a>DOMString</a>?</span> <span class="idlAttrName"><a href="#widl-RecordingError-message">message</a></span>;</span>
};</span></pre><section id="attributes-1"><h4><span class="secno">4.2.1 </span>Attributes</h4><dl class="attributes"><dt id="widl-RecordingError-message"><code>message</code> of type <span class="idlAttrType"><a>DOMString</a></span>, readonly, nullable</dt><dd>A human readable description of the error. This string may vary
          between different user agents.</dd><dt id="widl-RecordingError-name"><code>name</code> of type <span class="idlAttrType"><a>DOMString</a></span>, readonly</dt><dd>A string representing the type of error. This string must be one
          of those defined by the <code>RecordingExceptionName</code> or
          <code>RecordingErrorName</code> enums for the error object to be
          valid.</dd></dl></section>
      </section>



      <section id="recordingexceptionname">
        <h3><span class="secno">4.3 </span>RecordingExceptionName</h3>

        <pre class="idl"><span class="idlEnum" id="idl-def-RTCExceptionName">enum <span class="idlEnumID">RTCExceptionName</span> {
    "<span class="idlEnumItem">INVALID_MEDIASTREAM_TRACK_ID</span>",
    "<span class="idlEnumItem">INVALID_STATE</span>"
    "<span class="idlEnumItem">UNSUPPORTED_OPTION</span>"
};</span></pre><table class="simple"><tr><th colspan="2">Enumeration description</th></tr>
          	<tr><td><code>INVALID_MEDIASTREAM_TRACK_ID</code></td><td>The argument provided is not the ID of any
          <code>MediaStreamTrack</code> belonging to the <code>Media Recorder</code>'s <code>mediaStream</code>.</td></tr>
          	<tr><td><code>INVALID_STATE</code></td><td>The function was called on a <code>MediaRecorder</code> that
          is an invalid state, or a state in which the function is not allowed
          to be executed.</td></tr>
          <tr><td><code>UNSUPPORTED_OPTION</code></td><td>The UA cannot provide the codec or recording option that has
          	been requested.</td></tr>
          </table>
      </section>

      <section id="recordingerrorname">
        <h3><span class="secno">4.4 </span>RecordingErrorName</h3>

        <pre class="idl"><span class="idlEnum" id="idl-def-RecordingErrorName">enum <span class="idlEnumID">RecordingErrorName</span> {
    "<span class="idlEnumItem">OUT_OF_MEMORY</span>",
    "<span class="idlEnumItem">ILLEGAL_STREAM_MODIFICATION</span>"
     "<span class="idlEnumItem">OTHER_RECORDING_ERROR</span>"
};</span></pre><table class="simple"><tr><th colspan="2">Enumeration description</th></tr>
	<tr><td><code>OUT_OF_MEMORY</code></td><td>The UA has exhaused the available memory. User agents
          <em title="should" class="rfc2119">should</em> provide as much additional information in the error message as
          possible.</td></tr><tr><td><code>ILLEGAL_STREAM_MODIFICATION</code></td><td>A modification to
          	the <code>mediaStream</code> has occurred that makes it impossible to continue recording.
          	An example would be the addition of a Track while recording is occurring. User agents <em title="should" class="rfc2119">should</em> provide as much additional information in
          the error message as possible.</td></tr>
<tr><td><code>OTHER_RECORDING_ERROR</code></td><td>Used for an fatal error other than those listed
 	above. User agents
          <em title="should" class="rfc2119">should</em> provide as much additional information in the error message as
          possible.</td></tr>          
          </table>

      </section>
    </section>
    


 <section id="event-summary" class="informative">
   <h2><span class="secno">5.0 </span>Event summary</h2>


    <p>The following additional events fire on <code><a class="idlType" href="#idl-def-MediaRecorder"><code>MediaRecorder</code></a></code>
    objects:</p>

    <table style="border-width:0; width:60%" border="1">
      <tbody><tr>
        <th>Event name</th>

        <th>Interface</th>

        <th>Fired when...</th>
      </tr>

      </tbody><tbody>
        <tr>
          <td><dfn id="event-mediarecorder-recording"><code>recording</code></dfn></td>

          <td><a href="http://dev.w3.org/2011/webrtc/editor/webrtc.html#mediastreamevent"><code>MediaSteamEvent</code></a></td>

          <td>The UA has started recording data on the MediaStream.</td>
        </tr>

        <tr>
          <td><dfn id="event-mediarecorder-stoprecording"><code>stoprecording</code></dfn></td>

          <td><a href="http://dev.w3.org/2011/webrtc/editor/webrtc.html#mediastreamevent"><code>MediaSteamEvent</code></a></td>

          <td>The UA has stopped recording data on the MediaStream.</td>
        </tr>
        
        <tr>
          <td><dfn id="event-mediarecorder-dataavailable"><code>dataavailable</code></dfn></td>

          <td><a href="#idl-def-BlobEvent"><code>BlobEvent</code></a></td>
          <td>The UA generates this even to return data to the application.  The 'detail' attribute of this 
          	event contains a Blob of recorded data.</td>
        </tr>
        
         <tr>
          <td><dfn id="event-mediarecorder-photo"><code>photo</code></dfn></td>

          <td><a href="#idl-def-BlobEvent"><code>BlobEvent</code></a></td>

          <td>The UA uses this event to return a  photo to the application (as a Blob).  The 'detail' attribute of this 
          	event contains a Blob of recorded snapshot data.</td>
        </tr>
        
        <tr>
          <td><dfn id="event-mediarecorder-pause"><code>pause</code></dfn></td>

          <td><a href="http://dev.w3.org/2011/webrtc/editor/webrtc.html#mediastreamevent"><code>MediaSteamEvent</code></a></td>

          <td>The UA has paused recording data on the MediaStream.</td>
        </tr>
        
         <tr>
          <td><dfn id="event-mediarecorder-resume"><code>resume</code></dfn></td>

          <td><a href="http://dev.w3.org/2011/webrtc/editor/webrtc.html#mediastreamevent"><code>MediaSteamEvent</code></a></td>

          <td>The UA has resumed recording data on the MediaStream.</td>
        </tr>
        
         <tr>
          <td><dfn id="event-mediarecorder-mutetrackrecording"><code>mutetrackrecording</code></dfn></td>

          <td><a href="http://dev.w3.org/2011/webrtc/editor/getusermedia.html"><code>MediaSteamTrackEvent</code></a></td>

          <td>The MediaRecorder has muted recording on a Track.</td>
        </tr>
        
         <tr>
          <td><dfn id="event-mediarecorder-unmutetrackrecording"><code>unmutetrackrecording</code></dfn></td>

          <td><a href="http://dev.w3.org/2011/webrtc/editor/getusermedia.html"><code>MediaSteamTrackEvent</code></a></td>

          <td>The MediaRecorder has unmuted recording on a Track.</td>
        </tr>
  

        

        <tr>
          <td><dfn id="event-mediarecorder-recordingerror"><code>recordingerror</code></dfn></td>

          <td><a href="#idl-def-RecordingError"><code>RecordingError</code></a></td>

          <td>A fatal error has occurred and the UA has stopped recording. More  detailed error information
          	is available in the 'detail' attribute. </td>
        </tr>
        
          <tr>
          <td><dfn id="event-mediarecorder-recordingwarning"><code>recordingwarning</code></dfn></td>

          <td><code>CustomEvent</code></td>

          <td>A problem has occurred, but the UA has not stopped recording. More detailed information
          	is available in the 'detail' attribute. </td>
        </tr>

      </tbody>
    </table>

  </section>
  	
 <section class="appendix" id="openissues"><!--OddPage--><h2><span class="secno">A. </span>Open Issues</h2>
 	<ol>
 		<li>Do we need an MTI
        	format?</li>
        	<li>Do we need a "setSyncPoint()" operator and a "syncpoint" signal, 
        		so that the client can tell the recorder to insert a point at 
        		which a recording can be broken up (typically a new I-frame)? </li>
        		<li>For takePhoto, is the restriction that the Track's source have sourcetype "photocamera"
        			too strict? </li>
 		</ol>
</section>

<section class="appendix" id="references"><!--OddPage--><h2><span class="secno">B. </span>References</h2><section id="normative-references"><h3><span class="secno">B.1 </span>Normative references</h3>
	<dl class="bibliography"><dt id="bib-FILE-API">[FILE-API]</dt><dd>Arun Ranganathan; Jonas Sicking. <a href="http://www.w3.org/TR/2011/WD-FileAPI/"><cite>File API.</cite></a> 25 October 2012. W3C Working Draft. (Work in progress.) URL: <a href="http://www.w3.org/TR/2011/WD-FileAPI/">http://www.w3.org/TR/2011/WD-FileAPI/</a> </dl>
	<dl class="bibliography"><dt id="bib-mediacapture">[Media-Capture]</dt><dd>Daniel C. Burnett; Arant Narayan. <a href="http://dev.w3.org/2011/webrtc/editor/getusermedia.html"><cite>Media Capture and Streams.</cite></a> 15 November 2012. W3C Editors' Draft. (Work in progress.) URL: <a href="http://dev.w3.org/2011/webrtc/editor/getusermedia.html">http://dev.w3.org/2011/webrtc/editor/getusermedia.html</a> </dl>
</dd>
  </body></html>
